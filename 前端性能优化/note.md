性能优化点： -> 4个层面出发
1.网络层面
  使用cdn解决网络选择和缓存的问题，cdn只是请求静态资源，请求的cookie是无效的，
  避免访问cdn携带cookie
  cdn的域名和主站的域名不应该相同

2.构建层面

3.服务端层面

4.浏览器层面
  将dns的信息进行缓存，访问dns的时间会缩短很多。
## 资源的合并与压缩
  # 浏览器的一个请求从发送到返回经历了什么？
  # 请求过程中一些潜在的性能优化点
    dns是否可以通过缓存减少dns查询时间？
    网络请求过程走最近的网络环境？
    相同的静态资源是否可以缓存？
    能否减少请求http请求大小？
    减少http请求
    服务端渲染 -> 减少首屏加载的压力
## 图片的编解码原理和类型选择
    jpg 有损压缩，压缩率高，不支持透明
    
    jpeg

    svg矢量图 代码内嵌，相对较小，图片样式相对简单的场景
    
    png浏览器兼容好
    png8 ---- 256色   支持透明
    png24 --- 2^24色  不支持透明
    png32 --- 2^24色  支持透明

    每种图片格式有自己的特点，需要根据实际的需求选择合适的图片格式进行优化。
## 浏览器渲染机制
## 懒加载预加载
## PWA
## Vue-SSR

google首页案例学习
   学会使用fis3构建工具
1. html压缩
   -> 减少了代码空格和回车，删除无用字符(空格，制表符，换行符)，html注释也可以被压缩
   压缩方式？
     1. 使用在线网站进行压缩 (很少使用)
     2. nodejs提供了html-minifier工具
     3. 后端模板引擎渲染压缩
2. css压缩
   -> 无效代码删除
   -> css语义合并
   如何压缩？
     1. 使用在线网站进行压缩 (很少使用)
     2. 使用html-minifier对html中的css进行压缩
     3. 使用clean-css进行压缩
3. js的压缩与混淆
   -> 无效字符的删除
   -> 剔除注释
   -> 代码语义的缩减和优化
   -> 代码保护
   如何压缩？
     1. 使用在线网站进行压缩 (很少使用)
     2. 使用html-minifier对html中的js进行压缩
     3. 使用uglifyjs2对js进行压缩
4. 文件合并
     文件不合并的问题：
       1. 丢包问题影响严重
       2. 增加了网络延迟
       3. 经过代理服务器可能会被断开
    合并存在的问题：
       1. 首屏渲染的问题
       2. 缓存失效的问题  js合并之后文件改变，会导致缓存大面积失效。
    合并什么资源？
       1. 公共库合并 （与逻辑代码的合并分开来）
       2. 不同页面的合并
       3. 见机行事，随机应变
     什么是 keep-alive ??
     什么是tcp的三次握手 ??
5. 开启gzip


## 浏览器存储
1. localStorage
2. sessionStorage
     -> 会话维度的存储 例如： 用来存储当前的tag页面是否支持webp
3. indexDB
4. cookies 
     -> httponly 禁止js操作cookie
     -> 主域和cdn域名区分开来

## Service Workers产生的意义
首要特性：
   -> 拦截和处理网络请求的能力，包括以编程方式来管理被缓存的响应，去实现一个离线应用。
   -> 使用Service Worker在后台运行同时能和页面通信的能力，去实现大规模后台数据的处理。
js是单线程的，当进行大型数据的计算或者存储，会阻塞页面的渲染

将大型数据的计算交给其它线程，将计算好的结果返回主线程     

Service Workers是一个脚本，浏览器独立于当前网页，将其在后台运行。
chrome://inspect/#service-workers

## PWA（Progressive Web Apps）渐进式的WebAPP
-> 没有网络下   app能否加载出来？
-> 弱网环境下   站点能否快速加载出来？
-> 4G网络下     app是怎样的体验？

不同的环境下有不同的体验
可靠： 在没有网络的环境下也能提供基本的页面访问，而不会出现“未连接到互联网的页面”
快速： 针对网页渲染及网络数据访问有较好的优化。
融入： 应用可以被增加到手机桌面，并且和普通应用有全屏，推送等特性。

lighthouse 检测一个网站是否符合pwa标准


## 缓存策略
# httpHeader (Response Header / Request Headers)

  #Cache-Control
    max-age: （优先级高于 expires） 
       cache-control: max-age=3600
       在这段max-age时间内，客户端请求的资源的时候，不会向服务器发出请求，会直接去缓存拿数据
    s-maxage: （cdn缓存）
       cache-control: s-maxage=31536000 （设置public缓存，任何用户都可以访问，优先级高于max-age）
    no-cache:
       cache-control: no-cache,max-age=0 （no-cache避免去直接浏览器存储，不发请求到服务端）
    no-store:
       不适用任何缓存策略  

    优先级总结：
       s-maxage > max-age > expires
  
  #Expires
    缓存过期时间，用来指定资源到期的时间，是服务端的具体时间点
    告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求
    
  #Last-Modified / If-Modified-Since
    诞生缘由： 如何让客户端感知到服务器端的资源发生了变化呢？
      基于客户端和服务端协商的缓存机制
      Last-Modified ---> 服务端 
         !!!!!!!!!!!!（当服务端的资源是最新的资源的时候，会返回304，否则是200）
      If-Modified-Since ---> 客户端
    
    Last-modified的缺点？
       1.某些服务端不能获取精确的修改时间。
       2.文件修改的时间改了，但文件内容却没有变。  

  #Etag / If-None-Match
    Etag: Etag值是一个hash值
    If-None-Match: 客户端带过去请求服务端的hash值，看资源是否更改了
    优先级总结：
       e-tag > Last-Modified

#分级缓存策略
  200状态： --------->  第三步
     当浏览器本地没有缓存或者下一层失效时，
     或者用户点击了ctrl+f5时，浏览器直接
     去服务器下载最新的数据。

  304状态：  --------->  第二步
     这一层由last-modified/etag控制。当下
     一层失效时或用户点击refresh，f5时，浏
     览器就会发送请求给服务器,如果服务器端
     没有变化，则返回304给浏览器。

  200状态（from cache）:   --------->  第一步
     这一层由expires/cache-control控制
     1.expires(http1.0版有效)是绝对时间
     2.cache-control(http1.1版有效)，相对时间
     只要没有失效，浏览器只访问自己的缓存
                                  
    
